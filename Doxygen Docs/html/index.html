<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>TSL ASCII 2.0 Command Library: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TSL ASCII 2.0 Command Library
   &#160;<span id="projectnumber">v 1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">TSL ASCII 2.0 Command Library Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The library provides developers with a set of easy-to-configure commands that encapsulate the <em>TSL ASCII 2 Protocol</em> and a helper object to communicate with any compatible TSL Device.</p>
<h2>Getting Started</h2>
<p>This guide will outline the steps required to communicate with a TSL ASCII 2 compatible device.</p>
<h2>Set up the Xcode project</h2>
<p>The TSL Ascii Command library is supplied as a static framework that bundles together the library code and its associated header files. It requires Foundation.framework and ExternalAccessory.framework.</p>
<p><em>Add the TSLAsciiCommands framework to the project:</em></p>
<ul>
<li>Drag 'TSLAsciiCommands.framework' into the Frameworks group</li>
<li>In the dialog that appears<ul>
<li>Ensure your project is checked in the 'Add To Targets' section</li>
<li>_(Optional)_ Check 'Copy items into destination groups folder (if needed)' to copy the framework into the project</li>
</ul>
</li>
</ul>
<p><em>In the project target &gt; Build Phases:</em></p>
<ul>
<li>Add ExternalAccessory.Framework to the 'Link binaries With Libraries' section</li>
</ul>
<p>The 'LinkBinary with Libraries' should be similar to the project below:</p>
<div class="image">
<img src="./docs/Introduction images/LinkBinaries.png"  alt="The &apos;link binaries...&apos; settings" title="The &apos;link binaries...&apos; settings"/>
</div>
<p>To receive External Accessory Framework notifications for TSL Devices the App must declare support for the 'com.uk.tsl.rfid' accessory protocol:</p>
<p>In the 'project'-Info.plist (in Supporting Files group)</p>
<ul>
<li>Add the 'Suppported external accessory protocol' key</li>
<li>Set the value of 'Item 0' to 'com.uk.tsl.rfid'</li>
</ul>
<p>The 'project'-Info.plist should look similar to this:</p>
<div class="image">
<img src="./docs/Introduction images/ExternalAccessoryProtocolSupport.png"  alt="The &apos;Suppported external accessory protocol&apos; settings" title="The &apos;Suppported external accessory protocol&apos; settings"/>
</div>
<h2>Configuring the Library</h2>
<p>The TSLAsciiCommands library uses <code>NSASCIIEncoding</code> for <code>NSStrings</code> but is capable of operation in UTF8 mode where <em>incoming</em> data from the reader can be interpreted as UTF8 characters - this is particularly useful with Barcode data. To enable this mode use the <code>useUTF8</code> property on the <code><a class="el" href="interface_t_s_l_library_configuration.html">TSLLibraryConfiguration</a></code> class as follows: </p>
<pre class="fragment">[TSLLibraryConfiguration sharedInstance].useUTF8 = YES;
</pre><p>This option need only be set once at App launch.</p>
<h2>Connecting to the TSL Device</h2>
<p>All iOS compatible TSL devices are accessed using the <a href="https://developer.apple.com/library/ios/navigation/#section=Frameworks&amp;topic=ExternalAccessory">External Accessory Framework</a> and it is recommended that developers read the iOS documentation to understand when the application will receive notifications and how to obtain a list of connected devices.</p>
<p>An App can only communicate with one device at a time using the EA Framework however the <a class="el" href="protocol_t_s_l_ascii_command-p.html">TSLAsciiCommand</a> library makes switching between devices simple.</p>
<p>All communication and control of the TSL device is done using an instance of <a class="el" href="interface_t_s_l_ascii_commander.html">TSLAsciiCommander</a>: </p>
<pre class="fragment">#import "TSLAsciiCommander.h"

.
.

// Create the TSLAsciiCommander used to communicate with the TSL Reader
_commander = [[TSLAsciiCommander alloc] init];
</pre><p><a class="el" href="interface_t_s_l_ascii_commander.html">TSLAsciiCommander</a> is configured to talk to a specific TSL device using the <code>connect:</code> method which takes an <code>EAAccessory *</code> as its only parameter. So, for some <code>chosenDeviceIndex</code> into the list of connected TSL Devices the following code snippet shows how to change to the new device: </p>
<pre class="fragment">    // Disconnect from the current reader, if any
    [_commander disconnect];

    // Connect to the chosen TSL Reader
    _currentAccessory = [[[EAAccessoryManager sharedAccessoryManager] connectedAccessories] chosenDeviceIndex];
    [_commander connect:_currentAccessory];
</pre><p>The success of the connection attempt can be determined from the <code>connect:</code> method's BOOL return value.</p>
<p>It is acceptable to pass nil to <code>connect:</code>, in which case <a class="el" href="interface_t_s_l_ascii_commander.html">TSLAsciiCommander</a> will attempt to connect to the last successfully connected device.</p>
<p>At any time the <a class="el" href="interface_t_s_l_ascii_commander.html">TSLAsciiCommander</a> <code>isConnected</code> property indicates whether there is a reader currently connected. </p>
<pre class="fragment">    if( _commander.isConnected )
    {
        // Issue commands to the reader
        .
        .
    }
</pre><p>Background communication with the TSL device is not supported and the App should disconnect from the TSL device when moving to the background and reconnect when returning to the foreground. The following code illustrates how to achieve this (in AppDelegate.m): </p>
<pre class="fragment">    - (void)applicationDidEnterBackground:(UIApplication *)application
    {
        [commander disconnect];
    }

    - (void)applicationDidBecomeActive:(UIApplication *)application
    {
        // Attempt to reconnect to the last used accessory
        [commander connect:nil];
    }
</pre><p>TSL devices may be connected or disconnected at any time and the App should register for <code>EAAccessoryDidConnectNotification</code> and <code>EAAccessoryDidDisconnectNotification</code> to discover when the list of connected devices has changed.</p>
<p><em>Warning:</em> There is a <em>quirk</em> in the EA framework (iOS 5 &amp; 6) that causes the <code>EAAccessoryDidConnectNotification</code> with incomplete information for the connected device. Attempting to connect to such a device will fail. This seems to always be followed by a notification with correct information. A work-around for this is shown below (<code>_accessoryDidConnect:</code> is the notification handler); </p>
<pre class="fragment">    -(void) _accessoryDidConnect:(NSNotification *)notification
    {
        // Only do something if the accessory added has valid protocol strings
        EAAccessory *connectedAccessory = [[notification userInfo] objectForKey:EAAccessoryKey];
        if( connectedAccessory.protocolStrings.count != 0 )
        {
            // Do something
            .
            .
        }
    }
</pre><h2>Controlling and Communicating with the TSL Device</h2>
<p>Once a connection has been established to a TSL device it can be controlled and interrogated using instances derived from <code><a class="el" href="protocol_t_s_l_ascii_command-p.html">TSLAsciiCommand</a></code>. These objects encapsulate the powerful TSL ASCII 2 protocol and allow simple configuration using object properties. Once configured they are sent to the TSL device using <code><a class="el" href="interface_t_s_l_ascii_commander.html">TSLAsciiCommander</a></code>'s <code>executeCommand:</code> method: </p>
<pre class="fragment">    if( _commander.isConnected )
    {
        // Use the TSLInventoryCommand
        TSLInventoryCommand *invCommand = [[TSLInventoryCommand alloc] init];

        // Request that the signal strength of each transponder is also returned
        invCommand.includeTransponderRSSI = TSL_TriState_YES;

        [_commander executeCommand:invCommand];
    }
</pre><p>The above example will issue an asynchronous inventory command - the response to the command is handled elsewhere in the code.</p>
<p><b>About the Responder Chain</b></p>
<p><code><a class="el" href="interface_t_s_l_ascii_commander.html">TSLAsciiCommander</a></code> handles incoming responses from the reader using instances derived from <code><a class="el" href="protocol_t_s_l_ascii_command_responder-p.html">TSLAsciiCommandResponder</a></code> (responders) in a 'responder chain' (See <code>responderChain</code> property).</p>
<p>Each line of ASCII data received from the TSL device is passed to the <code>processReceivedLine:</code> method of each responder in the chain in order. The responder can choose to process this data based on its content. If the responder recognises and processes a particular line it can choose to prevent down-chain responders from seeing it by returning YES from the <code>processReceivedLine</code> method.</p>
<p>TSL devices, such as the 1128 Bluetooth Handheld UHF RFID Reader, can also generate incoming data through actions such as the user pulling the device trigger to initiate an inventory or barcode scan. The responder chain will see all data sent from the device no matter how it was initiated.</p>
<p>It can be useful to communicate with the TSL device in a synchronous mode where a command is executed and the thread then waits until the response has been received from the reader. Most of the commands from the TSL ASCII command library support this by being derived from <code><a class="el" href="interface_t_s_l_ascii_self_responder_command_base.html">TSLAsciiSelfResponderCommandBase</a></code>. These commands provide their own default response handling and use the incoming data to set appropriate properties e.g. <a class="el" href="interface_t_s_l_battery_status_command.html">TSLBatteryStatusCommand</a> can be executed synchronously and then its <code>batteryLevel</code> property holds the current battery level of the TSL device.</p>
<p>To use synchronous commands requires the addition of a special responder (the synchronousResponder) to <code><a class="el" href="interface_t_s_l_ascii_commander.html">TSLAsciiCommander</a></code>'s responder chain. This allows developers to determine where in the responder chain synchronous commands are handled. The following code example illustrates the construction of a responder chain: </p>
<pre class="fragment">    // Create the TSLAsciiCommander used to communicate with the TSL Reader
    _commander = [[TSLAsciiCommander alloc] init];

    // TSLAsciiCommander requires TSLAsciiResponders to handle incoming reader responses

    // Add a logger to the commander to output all reader responses to the log file
    [_commander addResponder:[[TSLLoggerResponder alloc] init]];

    // Some synchronous commands will be used in the app
    [_commander addSynchronousResponder];

    // Performing an inventory could potentially take a long time if many transponders are in range so it is best to handle responses asynchronously
    //
    // The TSLInventoryCommand is a TSLAsciiResponder for inventory responses and can have a delegate
    // (id&lt;TSLInventoryCommandTransponderReceivedDelegate&gt;) that is informed of each transponder as it is received

    // Create a TSLInventoryCommand
    _inventoryResponder = [[TSLInventoryCommand alloc] init];

    // Add self as the transponder delegate
    _inventoryResponder.transponderReceivedDelegate = self;

    // Pulling the Reader trigger will generate inventory responses that are not from the library.
    // To ensure these are also seen requires explicitly requesting handling of non-library command responses
    _inventoryResponder.captureNonLibraryResponses = YES;

    // Add the inventory responder to the commander's responder chain
    [_commander addResponder:_inventoryResponder];
</pre><p>In the above example the first responder added is <code><a class="el" href="interface_t_s_l_logger_responder.html">TSLLoggerResponder</a></code>. This responder simply outputs every line it receives, using NSLog, with a preceding "&gt;" added and then passes the data on to other responders. This is a powerful debugging tool providing an easy way to see all incoming data.</p>
<p>Next in the responder chain is the synchronous responder. So, all synchronous commands will execute after the logger responder. If the synchronous command executing does not recognise a line of data then it will pass it to the next responder in the chain.</p>
<p>The final responder in the chain is designed to recognise Inventory responses (<code><a class="el" href="interface_t_s_l_inventory_command.html">TSLInventoryCommand</a></code> used as a responder). By default this command only responds to inventory commands initiated using a <a class="el" href="interface_t_s_l_inventory_command.html">TSLInventoryCommand</a> but here it is configured to also handle trigger responses (<code>_inventoryResponder.captureNonLibraryResponses = YES;</code>).</p>
<p><b>Issuing Synchronous Commands</b></p>
<p>All commands in the library that support synchronous operation provide a factory method (<code>synchronousCommand</code>) to create a command pre-configured to operate synchronously. The code below demonstrates the use of synchronous commands to reset the TSL device and obtain its version information: </p>
<pre class="fragment">    // Ensure the reader is in a known (default) state
    // No information is returned by the reset command other than its succesful completion
    TSLFactoryDefaultsCommand * resetCommand = [TSLFactoryDefaultsCommand synchronousCommand];

    [_commander executeCommand:resetCommand];

    // Notify user device has been reset
    if( resetCommand.isSuccessful )
    {
        NSLog(@"Reader reset to Factory Defaults\n");
    }
    else
    {
        NSLog(@"!!! Unable to reset reader to Factory Defaults !!!\n");
    }

    // Get version information for the reader
    // Use the TSLVersionInformationCommand synchronously as the returned information is needed below
    TSLVersionInformationCommand * versionCommand = [TSLVersionInformationCommand synchronousCommand];

    [_commander executeCommand:versionCommand];

    // Log some of the values obtained
    NSLog( @"\n%-16s %@\n%-16s %@\n%-16s %@\n\n\n",
         "Manufacturer:", versionCommand.manufacturer,
         "Serial Number:", versionCommand.serialNumber,
         "Antenna SN:", versionCommand.antennaSerialNumber
         );
</pre><p><b>Command Response Lifecycle Methods</b></p>
<p>Commands also implement the <a class="el" href="protocol_t_s_l_ascii_command_response_notifying-p.html">TSLAsciiCommandResponseNotifying</a> protocol which allows access to the response lifecycle events responseBegan and responseEnded. When the response line from the reader contains the <code>CS:</code> header, the <code>responseBegan</code> event is signalled. When lines starting either <code>OK:</code> or <code>ER:</code> are received the <code>responseEnded</code> event occurs. Blocks are used to handle these events and are configured using responseBeganBlock and responseEndedBlock properties. The following code (taken from the Inventory sample) shows their usage: </p>
<pre class="fragment">    //
    // Use the responseBeganBlock and responseEndedBlock to change the colour of the reader label while a response is being received
    //
    // Note: the weakSelf is used to avoid warning of retain cycles when self is used
    __weak typeof(self) weakSelf = self;

    _inventoryResponder.responseBeganBlock = ^
    {
        dispatch_async(dispatch_get_main_queue(),^
                       {
                           weakSelf.currentReaderLabel.backgroundColor = [UIColor blueColor];
                           weakSelf.currentReaderLabel.textColor = [UIColor whiteColor];
                       });
    };
    _inventoryResponder.responseEndedBlock = ^
    {
        dispatch_async(dispatch_get_main_queue(),^
                       {
                           weakSelf.currentReaderLabel.backgroundColor = [UIColor clearColor];
                           weakSelf.currentReaderLabel.textColor = [UIColor blackColor];
                       });
    };
</pre><p><b>Handling Transponder Responses</b></p>
<p>Commands that can receive responses from one or more transponders, such as the <a class="el" href="interface_t_s_l_inventory_command.html">TSLInventoryCommand</a> or the <a class="el" href="interface_t_s_l_write_transponder_command.html">TSLWriteTransponderCommand</a>, provide access to each received transponder through either delegate or Block-based methods and sometimes both. Where both methods are supported, the delegate object's methods will be called first followed by the execution of any Block. Examples of both of these approaches are available in the sample code (See Inventory and ReadWrite projects).</p>
<p><b>Handling Device Switch Responses</b></p>
<p>If the connected device contains a switch (trigger) this can be used to initiate actions within the iOS App. The <a class="el" href="interface_t_s_l_switch_action_command.html">TSLSwitchActionCommand</a> can be used to disable any default device actions and enable asynchronous notifications of the switch state. To capture these responses a <a class="el" href="interface_t_s_l_switch_responder.html">TSLSwitchResponder</a> object can be added to the responder chain and provides a delegate method invoked whenever a new switch state is received. An alternate approach is to poll the switch from the App. Both methods are demonstrated in the Trigger sample project.</p>
<h2>Sample Code</h2>
<p>To see the above code techniques in action build and run the Sample projects provided with this documentation. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Nov 20 2015 16:00:25 for TSL ASCII 2.0 Command Library by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.3.1 </li>
  </ul>
</div>
</body>
</html>
